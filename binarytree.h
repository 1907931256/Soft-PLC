#ifndef BINARYTREE_H
#define BINARYTREE_H

/***
 * 第一步：生成二叉树
 * 1.从左到右，从上到下扫描梯级，有向下标记转向下
 * 没有的话继续向右扫描，每扫描到两个就新建一个AND
 * 节点，它是这两个节点的父节点，新建的这个AND接单继续
 * 参与构造二叉树，作为后续AND节点的子节点（如果有）
 * 2.若有向下标记，则从当前行的下一行，向下线的位置开始
 * 向左扫描，若有元件则新建一个OR节点，继续向左，直到节点之
 * 前有向上线存在，若有多于一个，仍然按照第一步方法建立
 * AND节点。OR节点为上一行已构建好的子树的根节点
 * 和新建的AND节点的父节点；若左边没有元件，则向右，也建立
 *
 * 节点排列顺序：最先扫描到的节点作为新建的AND或OR的左子节点
 * 所有图符节点都是二叉树的叶子节点，AND和OR节点都是非叶子节点，
 * AND和OR分别代表左右子树的串联和并联关系
 *第二步：生成指令表
 * 二叉树的遍历顺序为：先访问左子节点，然后右子节点，最后根节点
 *
 *
 * 步骤：
 * 1.检查是否有错误
 * 2.编译：梯形图->二叉树->指令表
 * 3.指令表的修正优化
 * http://www.docin.com/p-638846728.html

*/
class BinaryTree
{
public:
    BinaryTree();
    ~BinaryTree();
    //从左到右，从上到下扫描图
    int ScanNode();
    bool IsBehidBranch();
    bool IsFrontBranch();
};

#endif // BINARYTREE_H
